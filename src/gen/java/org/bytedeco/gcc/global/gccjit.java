// Targeted by JavaCPP version 1.5.6-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.gcc.global;

import org.bytedeco.gcc.gccjit.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class gccjit extends org.bytedeco.gcc.presets.gccjit {
    static { Loader.load(); }

// Parsed from <libgccjit.h>

/* A pure C API to enable client code to embed GCC as a JIT-compiler.
   Copyright (C) 2013-2020 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

// #ifndef LIBGCCJIT_H
// #define LIBGCCJIT_H

// #include <stdio.h>

// #ifdef __cplusplus
// Targeting ../gccjit/gcc_jit_context.java


// Targeting ../gccjit/gcc_jit_result.java


// Targeting ../gccjit/gcc_jit_object.java


// Targeting ../gccjit/gcc_jit_location.java


// Targeting ../gccjit/gcc_jit_type.java


// Targeting ../gccjit/gcc_jit_field.java


// Targeting ../gccjit/gcc_jit_struct.java


// Targeting ../gccjit/gcc_jit_function.java


// Targeting ../gccjit/gcc_jit_block.java


// Targeting ../gccjit/gcc_jit_rvalue.java


// Targeting ../gccjit/gcc_jit_lvalue.java


// Targeting ../gccjit/gcc_jit_param.java


// Targeting ../gccjit/gcc_jit_case.java



/* Acquire a JIT-compilation context.  */
public static native gcc_jit_context gcc_jit_context_acquire();

/* Release the context.  After this call, it's no longer valid to use
   the ctxt.  */
public static native void gcc_jit_context_release(gcc_jit_context ctxt);

/* Options present in the initial release of libgccjit.
   These were handled using enums.  */

/* Options taking string values. */
/** enum gcc_jit_str_option */
public static final int
  /* The name of the program, for use as a prefix when printing error
     messages to stderr.  If NULL, or default, "libgccjit.so" is used.  */
  GCC_JIT_STR_OPTION_PROGNAME = 0,

  GCC_JIT_NUM_STR_OPTIONS = 1;

/* Options taking int values. */
/** enum gcc_jit_int_option */
public static final int
  /* How much to optimize the code.
     Valid values are 0-3, corresponding to GCC's command-line options
     -O0 through -O3.

     The default value is 0 (unoptimized).  */
  GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL = 0,

  GCC_JIT_NUM_INT_OPTIONS = 1;

/* Options taking boolean values.
   These all default to "false".  */
/** enum gcc_jit_bool_option */
public static final int
  /* If true, gcc_jit_context_compile will attempt to do the right
     thing so that if you attach a debugger to the process, it will
     be able to inspect variables and step through your code.

     Note that you can't step through code unless you set up source
     location information for the code (by creating and passing in
     gcc_jit_location instances).  */
  GCC_JIT_BOOL_OPTION_DEBUGINFO = 0,

  /* If true, gcc_jit_context_compile will dump its initial "tree"
     representation of your code to stderr (before any
     optimizations).  */
  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE = 1,

  /* If true, gcc_jit_context_compile will dump the "gimple"
     representation of your code to stderr, before any optimizations
     are performed.  The dump resembles C code.  */
  GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE = 2,

  /* If true, gcc_jit_context_compile will dump the final
     generated code to stderr, in the form of assembly language.  */
  GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE = 3,

  /* If true, gcc_jit_context_compile will print information to stderr
     on the actions it is performing, followed by a profile showing
     the time taken and memory usage of each phase.
   */
  GCC_JIT_BOOL_OPTION_DUMP_SUMMARY = 4,

  /* If true, gcc_jit_context_compile will dump copious
     amount of information on what it's doing to various
     files within a temporary directory.  Use
     GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES (see below) to
     see the results.  The files are intended to be human-readable,
     but the exact files and their formats are subject to change.
  */
  GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING = 5,

  /* If true, libgccjit will aggressively run its garbage collector, to
     shake out bugs (greatly slowing down the compile).  This is likely
     to only be of interest to developers *of* the library.  It is
     used when running the selftest suite.  */
  GCC_JIT_BOOL_OPTION_SELFCHECK_GC = 6,

  /* If true, gcc_jit_context_release will not clean up
     intermediate files written to the filesystem, and will display
     their location on stderr.  */
  GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES = 7,

  GCC_JIT_NUM_BOOL_OPTIONS = 8;

/* Set a string option on the given context.

   The context takes a copy of the string, so the
   (const char *) buffer is not needed anymore after the call
   returns.  */
public static native void gcc_jit_context_set_str_option(gcc_jit_context ctxt,
				@Cast("gcc_jit_str_option") int opt,
				@Cast("const char*") BytePointer value);
public static native void gcc_jit_context_set_str_option(gcc_jit_context ctxt,
				@Cast("gcc_jit_str_option") int opt,
				String value);

/* Set an int option on the given context.  */
public static native void gcc_jit_context_set_int_option(gcc_jit_context ctxt,
				@Cast("gcc_jit_int_option") int opt,
				int value);

/* Set a boolean option on the given context.

   Zero is "false" (the default), non-zero is "true".  */
public static native void gcc_jit_context_set_bool_option(gcc_jit_context ctxt,
				 @Cast("gcc_jit_bool_option") int opt,
				 int value);

/* Options added after the initial release of libgccjit.
   These are handled by providing an entrypoint per option,
   rather than by extending the enum gcc_jit_*_option,
   so that client code that use these new options can be identified
   from binary metadata.  */

/* By default, libgccjit will issue an error about unreachable blocks
   within a function.

   This option can be used to disable that error.

   This entrypoint was added in LIBGCCJIT_ABI_2; you can test for
   its presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks
*/

public static native void gcc_jit_context_set_bool_allow_unreachable_blocks(gcc_jit_context ctxt,
						   int bool_value);

/* Pre-canned feature macro to indicate the presence of
   gcc_jit_context_set_bool_allow_unreachable_blocks.  This can be
   tested for with #ifdef.  */
// #define LIBGCCJIT_HAVE_gcc_jit_context_set_bool_allow_unreachable_blocks

/* Implementation detail:
   libgccjit internally generates assembler, and uses "driver" code
   for converting it to other formats (e.g. shared libraries).

   By default, libgccjit will use an embedded copy of the driver
   code.

   This option can be used to instead invoke an external driver executable
   as a subprocess.

   This entrypoint was added in LIBGCCJIT_ABI_5; you can test for
   its presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver
*/

public static native void gcc_jit_context_set_bool_use_external_driver(gcc_jit_context ctxt,
					      int bool_value);

/* Pre-canned feature macro to indicate the presence of
   gcc_jit_context_set_bool_use_external_driver.  This can be
   tested for with #ifdef.  */
// #define LIBGCCJIT_HAVE_gcc_jit_context_set_bool_use_external_driver

/* Add an arbitrary gcc command-line option to the context.
   The context takes a copy of the string, so the
   (const char *) optname is not needed anymore after the call
   returns.

   Note that only some options are likely to be meaningful; there is no
   "frontend" within libgccjit, so typically only those affecting
   optimization and code-generation are likely to be useful.

   This entrypoint was added in LIBGCCJIT_ABI_1; you can test for
   its presence using
   #ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_command_line_option
*/

public static native void gcc_jit_context_add_command_line_option(gcc_jit_context ctxt,
					 @Cast("const char*") BytePointer optname);
public static native void gcc_jit_context_add_command_line_option(gcc_jit_context ctxt,
					 String optname);

/* Pre-canned feature-test macro for detecting the presence of
   gcc_jit_context_add_command_line_option within libgccjit.h.  */

// #define LIBGCCJIT_HAVE_gcc_jit_context_add_command_line_option

/* Add an arbitrary gcc driver option to the context.
   The context takes a copy of the string, so the
   (const char *) optname is not needed anymore after the call
   returns.

   Note that only some options are likely to be meaningful; there is no
   "frontend" within libgccjit, so typically only those affecting
   assembler and linker are likely to be useful.

   This entrypoint was added in LIBGCCJIT_ABI_11; you can test for
   its presence using
   #ifdef LIBGCCJIT_HAVE_gcc_jit_context_add_driver_option
*/
public static native void gcc_jit_context_add_driver_option(gcc_jit_context ctxt,
				   @Cast("const char*") BytePointer optname);
public static native void gcc_jit_context_add_driver_option(gcc_jit_context ctxt,
				   String optname);

/* Pre-canned feature-test macro for detecting the presence of
   gcc_jit_context_add_driver_option within libgccjit.h.  */

// #define LIBGCCJIT_HAVE_gcc_jit_context_add_driver_option

/* Compile the context to in-memory machine code.

   This can be called more that once on a given context,
   although any errors that occur will block further compilation.  */

public static native gcc_jit_result gcc_jit_context_compile(gcc_jit_context ctxt);

/* Kinds of ahead-of-time compilation, for use with
   gcc_jit_context_compile_to_file.  */

/** enum gcc_jit_output_kind */
public static final int
  /* Compile the context to an assembler file.  */
  GCC_JIT_OUTPUT_KIND_ASSEMBLER = 0,

  /* Compile the context to an object file.  */
  GCC_JIT_OUTPUT_KIND_OBJECT_FILE = 1,

  /* Compile the context to a dynamic library.  */
  GCC_JIT_OUTPUT_KIND_DYNAMIC_LIBRARY = 2,

  /* Compile the context to an executable.  */
  GCC_JIT_OUTPUT_KIND_EXECUTABLE = 3;

/* Compile the context to a file of the given kind.

   This can be called more that once on a given context,
   although any errors that occur will block further compilation.  */

public static native void gcc_jit_context_compile_to_file(gcc_jit_context ctxt,
				 @Cast("gcc_jit_output_kind") int output_kind,
				 @Cast("const char*") BytePointer output_path);
public static native void gcc_jit_context_compile_to_file(gcc_jit_context ctxt,
				 @Cast("gcc_jit_output_kind") int output_kind,
				 String output_path);

/* To help with debugging: dump a C-like representation to the given path,
   describing what's been set up on the context.

   If "update_locations" is true, then also set up gcc_jit_location
   information throughout the context, pointing at the dump file as if it
   were a source file.  This may be of use in conjunction with
   GCC_JIT_BOOL_OPTION_DEBUGINFO to allow stepping through the code in a
   debugger.  */
public static native void gcc_jit_context_dump_to_file(gcc_jit_context ctxt,
			      @Cast("const char*") BytePointer path,
			      int update_locations);
public static native void gcc_jit_context_dump_to_file(gcc_jit_context ctxt,
			      String path,
			      int update_locations);

/* To help with debugging; enable ongoing logging of the context's
   activity to the given FILE *.

   The caller remains responsible for closing "logfile".

   Params "flags" and "verbosity" are reserved for future use, and
   must both be 0 for now.  */
public static native void gcc_jit_context_set_logfile(gcc_jit_context ctxt,
			     @Cast("FILE*") Pointer logfile,
			     int flags,
			     int verbosity);

/* To be called after any API call, this gives the first error message
   that occurred on the context.

   The returned string is valid for the rest of the lifetime of the
   context.

   If no errors occurred, this will be NULL.  */
public static native @Cast("const char*") BytePointer gcc_jit_context_get_first_error(gcc_jit_context ctxt);

/* To be called after any API call, this gives the last error message
   that occurred on the context.

   If no errors occurred, this will be NULL.

   If non-NULL, the returned string is only guaranteed to be valid until
   the next call to libgccjit relating to this context. */
public static native @Cast("const char*") BytePointer gcc_jit_context_get_last_error(gcc_jit_context ctxt);

/* Locate a given function within the built machine code.
   This will need to be cast to a function pointer of the
   correct type before it can be called. */
public static native Pointer gcc_jit_result_get_code(gcc_jit_result result,
			 @Cast("const char*") BytePointer funcname);
public static native Pointer gcc_jit_result_get_code(gcc_jit_result result,
			 String funcname);

/* Locate a given global within the built machine code.
   It must have been created using GCC_JIT_GLOBAL_EXPORTED.
   This is a ptr to the global, so e.g. for an int this is an int *.  */
public static native Pointer gcc_jit_result_get_global(gcc_jit_result result,
			   @Cast("const char*") BytePointer name);
public static native Pointer gcc_jit_result_get_global(gcc_jit_result result,
			   String name);

/* Once we're done with the code, this unloads the built .so file.
   This cleans up the result; after calling this, it's no longer
   valid to use the result.  */
public static native void gcc_jit_result_release(gcc_jit_result result);


/**********************************************************************
 Functions for creating "contextual" objects.
 <p>
 All objects created by these functions share the lifetime of the context
 they are created within, and are automatically cleaned up for you when
 you call gcc_jit_context_release on the context.
 <p>
 Note that this means you can't use references to them after you've
 released their context.
 <p>
 All (const char *) string arguments passed to these functions are
 copied, so you don't need to keep them around.
 <p>
 You create code by adding a sequence of statements to blocks.
**********************************************************************/

/**********************************************************************
 The base class of "contextual" object.
 **********************************************************************/
/* Which context is "obj" within?  */
public static native gcc_jit_context gcc_jit_object_get_context(gcc_jit_object obj);

/* Get a human-readable description of this object.
   The string buffer is created the first time this is called on a given
   object, and persists until the object's context is released.  */
public static native @Cast("const char*") BytePointer gcc_jit_object_get_debug_string(gcc_jit_object obj);

/**********************************************************************
 Debugging information.
 **********************************************************************/

/* Creating source code locations for use by the debugger.
   Line and column numbers are 1-based.  */
public static native gcc_jit_location gcc_jit_context_new_location(gcc_jit_context ctxt,
			      @Cast("const char*") BytePointer filename,
			      int line,
			      int column);
public static native gcc_jit_location gcc_jit_context_new_location(gcc_jit_context ctxt,
			      String filename,
			      int line,
			      int column);

/* Upcasting from location to object.  */
public static native gcc_jit_object gcc_jit_location_as_object(gcc_jit_location loc);


/**********************************************************************
 Types.
 **********************************************************************/

/* Upcasting from type to object.  */
public static native gcc_jit_object gcc_jit_type_as_object(gcc_jit_type type);

/* Access to specific types.  */
/** enum gcc_jit_types */
public static final int
  /* C's "void" type.  */
  GCC_JIT_TYPE_VOID = 0,

  /* "void *".  */
  GCC_JIT_TYPE_VOID_PTR = 1,

  /* C++'s bool type; also C99's "_Bool" type, aka "bool" if using
     stdbool.h.  */
  GCC_JIT_TYPE_BOOL = 2,

  /* Various integer types.  */

  /* C's "char" (of some signedness) and the variants where the
     signedness is specified.  */
  GCC_JIT_TYPE_CHAR = 3,
  GCC_JIT_TYPE_SIGNED_CHAR = 4,
  GCC_JIT_TYPE_UNSIGNED_CHAR = 5,

  /* C's "short" and "unsigned short".  */
  GCC_JIT_TYPE_SHORT = 6, /* signed */
  GCC_JIT_TYPE_UNSIGNED_SHORT = 7,

  /* C's "int" and "unsigned int".  */
  GCC_JIT_TYPE_INT = 8, /* signed */
  GCC_JIT_TYPE_UNSIGNED_INT = 9,

  /* C's "long" and "unsigned long".  */
  GCC_JIT_TYPE_LONG = 10, /* signed */
  GCC_JIT_TYPE_UNSIGNED_LONG = 11,

  /* C99's "long long" and "unsigned long long".  */
  GCC_JIT_TYPE_LONG_LONG = 12, /* signed */
  GCC_JIT_TYPE_UNSIGNED_LONG_LONG = 13,

  /* Floating-point types  */

  GCC_JIT_TYPE_FLOAT = 14,
  GCC_JIT_TYPE_DOUBLE = 15,
  GCC_JIT_TYPE_LONG_DOUBLE = 16,

  /* C type: (const char *).  */
  GCC_JIT_TYPE_CONST_CHAR_PTR = 17,

 /* The C "size_t" type.  */
  GCC_JIT_TYPE_SIZE_T = 18,

 /* C type: (FILE *)  */
  GCC_JIT_TYPE_FILE_PTR = 19,

  /* Complex numbers.  */
  GCC_JIT_TYPE_COMPLEX_FLOAT = 20,
  GCC_JIT_TYPE_COMPLEX_DOUBLE = 21,
  GCC_JIT_TYPE_COMPLEX_LONG_DOUBLE = 22;

public static native gcc_jit_type gcc_jit_context_get_type(gcc_jit_context ctxt,
			  @Cast("gcc_jit_types") int type_);

/* Get the integer type of the given size and signedness.  */
public static native gcc_jit_type gcc_jit_context_get_int_type(gcc_jit_context ctxt,
			      int num_bytes, int is_signed);

/* Constructing new types. */

/* Given type "T", get type "T*".  */
public static native gcc_jit_type gcc_jit_type_get_pointer(gcc_jit_type type);

/* Given type "T", get type "const T".  */
public static native gcc_jit_type gcc_jit_type_get_const(gcc_jit_type type);

/* Given type "T", get type "volatile T".  */
public static native gcc_jit_type gcc_jit_type_get_volatile(gcc_jit_type type);

/* Given type "T", get type "T[N]" (for a constant N).  */
public static native gcc_jit_type gcc_jit_context_new_array_type(gcc_jit_context ctxt,
				gcc_jit_location loc,
				gcc_jit_type element_type,
				int num_elements);

/* Struct-handling.  */

/* Create a field, for use within a struct or union.  */
public static native gcc_jit_field gcc_jit_context_new_field(gcc_jit_context ctxt,
			   gcc_jit_location loc,
			   gcc_jit_type type,
			   @Cast("const char*") BytePointer name);
public static native gcc_jit_field gcc_jit_context_new_field(gcc_jit_context ctxt,
			   gcc_jit_location loc,
			   gcc_jit_type type,
			   String name);

// #define LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield

/* Create a bit field, for use within a struct or union.

   This API entrypoint was added in LIBGCCJIT_ABI_12; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield
*/
public static native gcc_jit_field gcc_jit_context_new_bitfield(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      gcc_jit_type type,
			      int width,
			      @Cast("const char*") BytePointer name);
public static native gcc_jit_field gcc_jit_context_new_bitfield(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      gcc_jit_type type,
			      int width,
			      String name);

/* Upcasting from field to object.  */
public static native gcc_jit_object gcc_jit_field_as_object(gcc_jit_field field);

/* Create a struct type from an array of fields.  */
public static native gcc_jit_struct gcc_jit_context_new_struct_type(gcc_jit_context ctxt,
				 gcc_jit_location loc,
				 @Cast("const char*") BytePointer name,
				 int num_fields,
				 @Cast("gcc_jit_field**") PointerPointer fields);
public static native gcc_jit_struct gcc_jit_context_new_struct_type(gcc_jit_context ctxt,
				 gcc_jit_location loc,
				 @Cast("const char*") BytePointer name,
				 int num_fields,
				 @ByPtrPtr gcc_jit_field fields);
public static native gcc_jit_struct gcc_jit_context_new_struct_type(gcc_jit_context ctxt,
				 gcc_jit_location loc,
				 String name,
				 int num_fields,
				 @ByPtrPtr gcc_jit_field fields);

/* Create an opaque struct type.  */
public static native gcc_jit_struct gcc_jit_context_new_opaque_struct(gcc_jit_context ctxt,
				   gcc_jit_location loc,
				   @Cast("const char*") BytePointer name);
public static native gcc_jit_struct gcc_jit_context_new_opaque_struct(gcc_jit_context ctxt,
				   gcc_jit_location loc,
				   String name);

/* Upcast a struct to a type.  */
public static native gcc_jit_type gcc_jit_struct_as_type(gcc_jit_struct struct_type);

/* Populating the fields of a formerly-opaque struct type.
   This can only be called once on a given struct type.  */
public static native void gcc_jit_struct_set_fields(gcc_jit_struct struct_type,
			   gcc_jit_location loc,
			   int num_fields,
			   @Cast("gcc_jit_field**") PointerPointer fields);
public static native void gcc_jit_struct_set_fields(gcc_jit_struct struct_type,
			   gcc_jit_location loc,
			   int num_fields,
			   @ByPtrPtr gcc_jit_field fields);

/* Unions work similarly to structs.  */
public static native gcc_jit_type gcc_jit_context_new_union_type(gcc_jit_context ctxt,
				gcc_jit_location loc,
				@Cast("const char*") BytePointer name,
				int num_fields,
				@Cast("gcc_jit_field**") PointerPointer fields);
public static native gcc_jit_type gcc_jit_context_new_union_type(gcc_jit_context ctxt,
				gcc_jit_location loc,
				@Cast("const char*") BytePointer name,
				int num_fields,
				@ByPtrPtr gcc_jit_field fields);
public static native gcc_jit_type gcc_jit_context_new_union_type(gcc_jit_context ctxt,
				gcc_jit_location loc,
				String name,
				int num_fields,
				@ByPtrPtr gcc_jit_field fields);

/* Function pointers. */

public static native gcc_jit_type gcc_jit_context_new_function_ptr_type(gcc_jit_context ctxt,
				       gcc_jit_location loc,
				       gcc_jit_type return_type,
				       int num_params,
				       @Cast("gcc_jit_type**") PointerPointer param_types,
				       int is_variadic);
public static native gcc_jit_type gcc_jit_context_new_function_ptr_type(gcc_jit_context ctxt,
				       gcc_jit_location loc,
				       gcc_jit_type return_type,
				       int num_params,
				       @ByPtrPtr gcc_jit_type param_types,
				       int is_variadic);

/**********************************************************************
 Constructing functions.
 **********************************************************************/
/* Create a function param.  */
public static native gcc_jit_param gcc_jit_context_new_param(gcc_jit_context ctxt,
			   gcc_jit_location loc,
			   gcc_jit_type type,
			   @Cast("const char*") BytePointer name);
public static native gcc_jit_param gcc_jit_context_new_param(gcc_jit_context ctxt,
			   gcc_jit_location loc,
			   gcc_jit_type type,
			   String name);

/* Upcasting from param to object.  */
public static native gcc_jit_object gcc_jit_param_as_object(gcc_jit_param param);

/* Upcasting from param to lvalue.  */
public static native gcc_jit_lvalue gcc_jit_param_as_lvalue(gcc_jit_param param);

/* Upcasting from param to rvalue.  */
public static native gcc_jit_rvalue gcc_jit_param_as_rvalue(gcc_jit_param param);

/* Kinds of function.  */
/** enum gcc_jit_function_kind */
public static final int
  /* Function is defined by the client code and visible
     by name outside of the JIT.  */
  GCC_JIT_FUNCTION_EXPORTED = 0,

  /* Function is defined by the client code, but is invisible
     outside of the JIT.  Analogous to a "static" function.  */
  GCC_JIT_FUNCTION_INTERNAL = 1,

  /* Function is not defined by the client code; we're merely
     referring to it.  Analogous to using an "extern" function from a
     header file.  */
  GCC_JIT_FUNCTION_IMPORTED = 2,

  /* Function is only ever inlined into other functions, and is
     invisible outside of the JIT.

     Analogous to prefixing with "inline" and adding
     __attribute__((always_inline)).

     Inlining will only occur when the optimization level is
     above 0; when optimization is off, this is essentially the
     same as GCC_JIT_FUNCTION_INTERNAL.  */
  GCC_JIT_FUNCTION_ALWAYS_INLINE = 3;

/* Create a function.  */
public static native gcc_jit_function gcc_jit_context_new_function(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      @Cast("gcc_jit_function_kind") int kind,
			      gcc_jit_type return_type,
			      @Cast("const char*") BytePointer name,
			      int num_params,
			      @Cast("gcc_jit_param**") PointerPointer params,
			      int is_variadic);
public static native gcc_jit_function gcc_jit_context_new_function(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      @Cast("gcc_jit_function_kind") int kind,
			      gcc_jit_type return_type,
			      @Cast("const char*") BytePointer name,
			      int num_params,
			      @ByPtrPtr gcc_jit_param params,
			      int is_variadic);
public static native gcc_jit_function gcc_jit_context_new_function(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      @Cast("gcc_jit_function_kind") int kind,
			      gcc_jit_type return_type,
			      String name,
			      int num_params,
			      @ByPtrPtr gcc_jit_param params,
			      int is_variadic);

/* Create a reference to a builtin function (sometimes called
   intrinsic functions).  */
public static native gcc_jit_function gcc_jit_context_get_builtin_function(gcc_jit_context ctxt,
				      @Cast("const char*") BytePointer name);
public static native gcc_jit_function gcc_jit_context_get_builtin_function(gcc_jit_context ctxt,
				      String name);

/* Upcasting from function to object.  */
public static native gcc_jit_object gcc_jit_function_as_object(gcc_jit_function func);

/* Get a specific param of a function by index.  */
public static native gcc_jit_param gcc_jit_function_get_param(gcc_jit_function func, int index);

/* Emit the function in graphviz format.  */
public static native void gcc_jit_function_dump_to_dot(gcc_jit_function func,
			      @Cast("const char*") BytePointer path);
public static native void gcc_jit_function_dump_to_dot(gcc_jit_function func,
			      String path);

/* Create a block.

   The name can be NULL, or you can give it a meaningful name, which
   may show up in dumps of the internal representation, and in error
   messages.  */
public static native gcc_jit_block gcc_jit_function_new_block(gcc_jit_function func,
			    @Cast("const char*") BytePointer name);
public static native gcc_jit_block gcc_jit_function_new_block(gcc_jit_function func,
			    String name);

/* Upcasting from block to object.  */
public static native gcc_jit_object gcc_jit_block_as_object(gcc_jit_block block);

/* Which function is this block within?  */
public static native gcc_jit_function gcc_jit_block_get_function(gcc_jit_block block);

/**********************************************************************
 lvalues, rvalues and expressions.
 **********************************************************************/
/** enum gcc_jit_global_kind */
public static final int
  /* Global is defined by the client code and visible
     by name outside of this JIT context via gcc_jit_result_get_global.  */
  GCC_JIT_GLOBAL_EXPORTED = 0,

  /* Global is defined by the client code, but is invisible
     outside of this JIT context.  Analogous to a "static" global.  */
  GCC_JIT_GLOBAL_INTERNAL = 1,

  /* Global is not defined by the client code; we're merely
     referring to it.  Analogous to using an "extern" global from a
     header file.  */
  GCC_JIT_GLOBAL_IMPORTED = 2;

public static native gcc_jit_lvalue gcc_jit_context_new_global(gcc_jit_context ctxt,
			    gcc_jit_location loc,
			    @Cast("gcc_jit_global_kind") int kind,
			    gcc_jit_type type,
			    @Cast("const char*") BytePointer name);
public static native gcc_jit_lvalue gcc_jit_context_new_global(gcc_jit_context ctxt,
			    gcc_jit_location loc,
			    @Cast("gcc_jit_global_kind") int kind,
			    gcc_jit_type type,
			    String name);

/* Upcasting.  */
public static native gcc_jit_object gcc_jit_lvalue_as_object(gcc_jit_lvalue lvalue);

public static native gcc_jit_rvalue gcc_jit_lvalue_as_rvalue(gcc_jit_lvalue lvalue);

public static native gcc_jit_object gcc_jit_rvalue_as_object(gcc_jit_rvalue rvalue);

public static native gcc_jit_type gcc_jit_rvalue_get_type(gcc_jit_rvalue rvalue);

/* Integer constants. */
public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_int(gcc_jit_context ctxt,
				     gcc_jit_type numeric_type,
				     int value);

public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_long(gcc_jit_context ctxt,
				      gcc_jit_type numeric_type,
				      long value);

public static native gcc_jit_rvalue gcc_jit_context_zero(gcc_jit_context ctxt,
		      gcc_jit_type numeric_type);

public static native gcc_jit_rvalue gcc_jit_context_one(gcc_jit_context ctxt,
		     gcc_jit_type numeric_type);

/* Floating-point constants.  */
public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_double(gcc_jit_context ctxt,
					gcc_jit_type numeric_type,
					double value);

/* Pointers.  */
public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_ptr(gcc_jit_context ctxt,
				     gcc_jit_type pointer_type,
				     Pointer value);

public static native gcc_jit_rvalue gcc_jit_context_null(gcc_jit_context ctxt,
		      gcc_jit_type pointer_type);

/* String literals. */
public static native gcc_jit_rvalue gcc_jit_context_new_string_literal(gcc_jit_context ctxt,
				    @Cast("const char*") BytePointer value);
public static native gcc_jit_rvalue gcc_jit_context_new_string_literal(gcc_jit_context ctxt,
				    String value);

/** enum gcc_jit_unary_op */
public static final int
  /* Negate an arithmetic value; analogous to:
       -(EXPR)
     in C.  */
  GCC_JIT_UNARY_OP_MINUS = 0,

  /* Bitwise negation of an integer value (one's complement); analogous
     to:
       ~(EXPR)
     in C.  */
  GCC_JIT_UNARY_OP_BITWISE_NEGATE = 1,

  /* Logical negation of an arithmetic or pointer value; analogous to:
       !(EXPR)
     in C.  */
  GCC_JIT_UNARY_OP_LOGICAL_NEGATE = 2,

  /* Absolute value of an arithmetic expression; analogous to:
       abs (EXPR)
     in C.  */
  GCC_JIT_UNARY_OP_ABS = 3;

public static native gcc_jit_rvalue gcc_jit_context_new_unary_op(gcc_jit_context ctxt,
			      gcc_jit_location loc,
			      @Cast("gcc_jit_unary_op") int op,
			      gcc_jit_type result_type,
			      gcc_jit_rvalue rvalue);

/** enum gcc_jit_binary_op */
public static final int
  /* Addition of arithmetic values; analogous to:
       (EXPR_A) + (EXPR_B)
     in C.
     For pointer addition, use gcc_jit_context_new_array_access.  */
  GCC_JIT_BINARY_OP_PLUS = 0,

  /* Subtraction of arithmetic values; analogous to:
       (EXPR_A) - (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_MINUS = 1,

  /* Multiplication of a pair of arithmetic values; analogous to:
       (EXPR_A) * (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_MULT = 2,

  /* Quotient of division of arithmetic values; analogous to:
       (EXPR_A) / (EXPR_B)
     in C.
     The result type affects the kind of division: if the result type is
     integer-based, then the result is truncated towards zero, whereas
     a floating-point result type indicates floating-point division.  */
  GCC_JIT_BINARY_OP_DIVIDE = 3,

  /* Remainder of division of arithmetic values; analogous to:
       (EXPR_A) % (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_MODULO = 4,

  /* Bitwise AND; analogous to:
       (EXPR_A) & (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_BITWISE_AND = 5,

  /* Bitwise exclusive OR; analogous to:
       (EXPR_A) ^ (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_BITWISE_XOR = 6,

  /* Bitwise inclusive OR; analogous to:
       (EXPR_A) | (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_BITWISE_OR = 7,

  /* Logical AND; analogous to:
       (EXPR_A) && (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_LOGICAL_AND = 8,

  /* Logical OR; analogous to:
       (EXPR_A) || (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_LOGICAL_OR = 9,

  /* Left shift; analogous to:
       (EXPR_A) << (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_LSHIFT = 10,

  /* Right shift; analogous to:
       (EXPR_A) >> (EXPR_B)
     in C.  */
  GCC_JIT_BINARY_OP_RSHIFT = 11;

public static native gcc_jit_rvalue gcc_jit_context_new_binary_op(gcc_jit_context ctxt,
			       gcc_jit_location loc,
			       @Cast("gcc_jit_binary_op") int op,
			       gcc_jit_type result_type,
			       gcc_jit_rvalue a, gcc_jit_rvalue b);

/* (Comparisons are treated as separate from "binary_op" to save
   you having to specify the result_type).  */

/** enum gcc_jit_comparison */
public static final int
  /* (EXPR_A) == (EXPR_B).  */
  GCC_JIT_COMPARISON_EQ = 0,

  /* (EXPR_A) != (EXPR_B).  */
  GCC_JIT_COMPARISON_NE = 1,

  /* (EXPR_A) < (EXPR_B).  */
  GCC_JIT_COMPARISON_LT = 2,

  /* (EXPR_A) <=(EXPR_B).  */
  GCC_JIT_COMPARISON_LE = 3,

  /* (EXPR_A) > (EXPR_B).  */
  GCC_JIT_COMPARISON_GT = 4,

  /* (EXPR_A) >= (EXPR_B).  */
  GCC_JIT_COMPARISON_GE = 5;

public static native gcc_jit_rvalue gcc_jit_context_new_comparison(gcc_jit_context ctxt,
				gcc_jit_location loc,
				@Cast("gcc_jit_comparison") int op,
				gcc_jit_rvalue a, gcc_jit_rvalue b);

/* Function calls.  */

/* Call of a specific function.  */
public static native gcc_jit_rvalue gcc_jit_context_new_call(gcc_jit_context ctxt,
			  gcc_jit_location loc,
			  gcc_jit_function func,
			  int numargs, @Cast("gcc_jit_rvalue**") PointerPointer args);
public static native gcc_jit_rvalue gcc_jit_context_new_call(gcc_jit_context ctxt,
			  gcc_jit_location loc,
			  gcc_jit_function func,
			  int numargs, @ByPtrPtr gcc_jit_rvalue args);

/* Call through a function pointer.  */
public static native gcc_jit_rvalue gcc_jit_context_new_call_through_ptr(gcc_jit_context ctxt,
				      gcc_jit_location loc,
				      gcc_jit_rvalue fn_ptr,
				      int numargs, @Cast("gcc_jit_rvalue**") PointerPointer args);
public static native gcc_jit_rvalue gcc_jit_context_new_call_through_ptr(gcc_jit_context ctxt,
				      gcc_jit_location loc,
				      gcc_jit_rvalue fn_ptr,
				      int numargs, @ByPtrPtr gcc_jit_rvalue args);

/* Type-coercion.

   Currently only a limited set of conversions are possible:
     int <-> float
     int <-> bool  */
public static native gcc_jit_rvalue gcc_jit_context_new_cast(gcc_jit_context ctxt,
			  gcc_jit_location loc,
			  gcc_jit_rvalue rvalue,
			  gcc_jit_type type);

public static native gcc_jit_lvalue gcc_jit_context_new_array_access(gcc_jit_context ctxt,
				  gcc_jit_location loc,
				  gcc_jit_rvalue ptr,
				  gcc_jit_rvalue index);

/* Field access is provided separately for both lvalues and rvalues.  */

/* Accessing a field of an lvalue of struct type, analogous to:
      (EXPR).field = ...;
   in C.  */
public static native gcc_jit_lvalue gcc_jit_lvalue_access_field(gcc_jit_lvalue struct_or_union,
			     gcc_jit_location loc,
			     gcc_jit_field field);

/* Accessing a field of an rvalue of struct type, analogous to:
      (EXPR).field
   in C.  */
public static native gcc_jit_rvalue gcc_jit_rvalue_access_field(gcc_jit_rvalue struct_or_union,
			     gcc_jit_location loc,
			     gcc_jit_field field);

/* Accessing a field of an rvalue of pointer type, analogous to:
      (EXPR)->field
   in C, itself equivalent to (*EXPR).FIELD  */
public static native gcc_jit_lvalue gcc_jit_rvalue_dereference_field(gcc_jit_rvalue ptr,
				  gcc_jit_location loc,
				  gcc_jit_field field);

/* Dereferencing a pointer; analogous to:
     *(EXPR)
*/
public static native gcc_jit_lvalue gcc_jit_rvalue_dereference(gcc_jit_rvalue rvalue,
			    gcc_jit_location loc);

/* Taking the address of an lvalue; analogous to:
     &(EXPR)
   in C.  */
public static native gcc_jit_rvalue gcc_jit_lvalue_get_address(gcc_jit_lvalue lvalue,
			    gcc_jit_location loc);

public static native gcc_jit_lvalue gcc_jit_function_new_local(gcc_jit_function func,
			    gcc_jit_location loc,
			    gcc_jit_type type,
			    @Cast("const char*") BytePointer name);
public static native gcc_jit_lvalue gcc_jit_function_new_local(gcc_jit_function func,
			    gcc_jit_location loc,
			    gcc_jit_type type,
			    String name);

/**********************************************************************
 Statement-creation.
 **********************************************************************/

/* Add evaluation of an rvalue, discarding the result
   (e.g. a function call that "returns" void).

   This is equivalent to this C code:

     (void)expression;
*/
public static native void gcc_jit_block_add_eval(gcc_jit_block block,
			gcc_jit_location loc,
			gcc_jit_rvalue rvalue);

/* Add evaluation of an rvalue, assigning the result to the given
   lvalue.

   This is roughly equivalent to this C code:

     lvalue = rvalue;
*/
public static native void gcc_jit_block_add_assignment(gcc_jit_block block,
			      gcc_jit_location loc,
			      gcc_jit_lvalue lvalue,
			      gcc_jit_rvalue rvalue);

/* Add evaluation of an rvalue, using the result to modify an
   lvalue.

   This is analogous to "+=" and friends:

     lvalue += rvalue;
     lvalue *= rvalue;
     lvalue /= rvalue;
   etc  */
public static native void gcc_jit_block_add_assignment_op(gcc_jit_block block,
				 gcc_jit_location loc,
				 gcc_jit_lvalue lvalue,
				 @Cast("gcc_jit_binary_op") int op,
				 gcc_jit_rvalue rvalue);

/* Add a no-op textual comment to the internal representation of the
   code.  It will be optimized away, but will be visible in the dumps
   seen via
     GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE
   and
     GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,
   and thus may be of use when debugging how your project's internal
   representation gets converted to the libgccjit IR.  */
public static native void gcc_jit_block_add_comment(gcc_jit_block block,
			   gcc_jit_location loc,
			   @Cast("const char*") BytePointer text);
public static native void gcc_jit_block_add_comment(gcc_jit_block block,
			   gcc_jit_location loc,
			   String text);

/* Terminate a block by adding evaluation of an rvalue, branching on the
   result to the appropriate successor block.

   This is roughly equivalent to this C code:

     if (boolval)
       goto on_true;
     else
       goto on_false;

   block, boolval, on_true, and on_false must be non-NULL.  */
public static native void gcc_jit_block_end_with_conditional(gcc_jit_block block,
				    gcc_jit_location loc,
				    gcc_jit_rvalue boolval,
				    gcc_jit_block on_true,
				    gcc_jit_block on_false);

/* Terminate a block by adding a jump to the given target block.

   This is roughly equivalent to this C code:

      goto target;
*/
public static native void gcc_jit_block_end_with_jump(gcc_jit_block block,
			     gcc_jit_location loc,
			     gcc_jit_block target);

/* Terminate a block by adding evaluation of an rvalue, returning the value.

   This is roughly equivalent to this C code:

      return expression;
*/
public static native void gcc_jit_block_end_with_return(gcc_jit_block block,
			       gcc_jit_location loc,
			       gcc_jit_rvalue rvalue);

/* Terminate a block by adding a valueless return, for use within a function
   with "void" return type.

   This is equivalent to this C code:

      return;
*/
public static native void gcc_jit_block_end_with_void_return(gcc_jit_block block,
				    gcc_jit_location loc);

/* Create a new gcc_jit_case instance for use in a switch statement.
   min_value and max_value must be constants of integer type.

   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
*/
public static native gcc_jit_case gcc_jit_context_new_case(gcc_jit_context ctxt,
			  gcc_jit_rvalue min_value,
			  gcc_jit_rvalue max_value,
			  gcc_jit_block dest_block);

/* Upcasting from case to object.

   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
*/

public static native gcc_jit_object gcc_jit_case_as_object(gcc_jit_case case_);

/* Terminate a block by adding evalation of an rvalue, then performing
   a multiway branch.

   This is roughly equivalent to this C code:

     switch (expr)
       {
       default:
	 goto default_block;

       case C0.min_value ... C0.max_value:
	 goto C0.dest_block;

       case C1.min_value ... C1.max_value:
	 goto C1.dest_block;

       ...etc...

       case C[N - 1].min_value ... C[N - 1].max_value:
	 goto C[N - 1].dest_block;
     }

   block, expr, default_block and cases must all be non-NULL.

   expr must be of the same integer type as all of the min_value
   and max_value within the cases.

   num_cases must be >= 0.

   The ranges of the cases must not overlap (or have duplicate
   values).

   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS
*/

public static native void gcc_jit_block_end_with_switch(gcc_jit_block block,
			       gcc_jit_location loc,
			       gcc_jit_rvalue expr,
			       gcc_jit_block default_block,
			       int num_cases,
			       @Cast("gcc_jit_case**") PointerPointer cases);
public static native void gcc_jit_block_end_with_switch(gcc_jit_block block,
			       gcc_jit_location loc,
			       gcc_jit_rvalue expr,
			       gcc_jit_block default_block,
			       int num_cases,
			       @ByPtrPtr gcc_jit_case cases);

/* Pre-canned feature macro to indicate the presence of
   gcc_jit_block_end_with_switch, gcc_jit_case_as_object, and
   gcc_jit_context_new_case.

   This can be tested for with #ifdef.  */
// #define LIBGCCJIT_HAVE_SWITCH_STATEMENTS

/**********************************************************************
 Nested contexts.
 **********************************************************************/

/* Given an existing JIT context, create a child context.

   The child inherits a copy of all option-settings from the parent.

   The child can reference objects created within the parent, but not
   vice-versa.

   The lifetime of the child context must be bounded by that of the
   parent: you should release a child context before releasing the parent
   context.

   If you use a function from a parent context within a child context,
   you have to compile the parent context before you can compile the
   child context, and the gcc_jit_result of the parent context must
   outlive the gcc_jit_result of the child context.

   This allows caching of shared initializations.  For example, you could
   create types and declarations of global functions in a parent context
   once within a process, and then create child contexts whenever a
   function or loop becomes hot. Each such child context can be used for
   JIT-compiling just one function or loop, but can reference types
   and helper functions created within the parent context.

   Contexts can be arbitrarily nested, provided the above rules are
   followed, but it's probably not worth going above 2 or 3 levels, and
   there will likely be a performance hit for such nesting.  */

public static native gcc_jit_context gcc_jit_context_new_child_context(gcc_jit_context parent_ctxt);

/**********************************************************************
 Implementation support.
 **********************************************************************/

/* Write C source code into "path" that can be compiled into a
   self-contained executable (i.e. with libgccjit as the only dependency).
   The generated code will attempt to replay the API calls that have been
   made into the given context.

   This may be useful when debugging the library or client code, for
   reducing a complicated recipe for reproducing a bug into a simpler
   form.

   Typically you need to supply the option "-Wno-unused-variable" when
   compiling the generated file (since the result of each API call is
   assigned to a unique variable within the generated C source, and not
   all are necessarily then used).  */

public static native void gcc_jit_context_dump_reproducer_to_file(gcc_jit_context ctxt,
					 @Cast("const char*") BytePointer path);
public static native void gcc_jit_context_dump_reproducer_to_file(gcc_jit_context ctxt,
					 String path);

/* Enable the dumping of a specific set of internal state from the
   compilation, capturing the result in-memory as a buffer.

   Parameter "dumpname" corresponds to the equivalent gcc command-line
   option, without the "-fdump-" prefix.
   For example, to get the equivalent of "-fdump-tree-vrp1", supply
   "tree-vrp1".
   The context directly stores the dumpname as a (const char *), so the
   passed string must outlive the context.

   gcc_jit_context_compile and gcc_jit_context_to_file
   will capture the dump as a dynamically-allocated buffer, writing
   it to ``*out_ptr``.

   The caller becomes responsible for calling
      free (*out_ptr)
   each time that gcc_jit_context_compile or gcc_jit_context_to_file
   are called.  *out_ptr will be written to, either with the address of a
   buffer, or with NULL if an error occurred.

   This API entrypoint is likely to be less stable than the others.
   In particular, both the precise dumpnames, and the format and content
   of the dumps are subject to change.

   It exists primarily for writing the library's own test suite.  */

public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     @Cast("const char*") BytePointer dumpname,
			     @Cast("char**") PointerPointer out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     @Cast("const char*") BytePointer dumpname,
			     @Cast("char**") @ByPtrPtr BytePointer out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     String dumpname,
			     @Cast("char**") @ByPtrPtr ByteBuffer out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     @Cast("const char*") BytePointer dumpname,
			     @Cast("char**") @ByPtrPtr byte[] out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     String dumpname,
			     @Cast("char**") @ByPtrPtr BytePointer out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     @Cast("const char*") BytePointer dumpname,
			     @Cast("char**") @ByPtrPtr ByteBuffer out_ptr);
public static native void gcc_jit_context_enable_dump(gcc_jit_context ctxt,
			     String dumpname,
			     @Cast("char**") @ByPtrPtr byte[] out_ptr);

/**********************************************************************
 Timing support.
 **********************************************************************/

/* The timing API was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/
// #define LIBGCCJIT_HAVE_TIMING_API
// Targeting ../gccjit/gcc_jit_timer.java



/* Create a gcc_jit_timer instance, and start timing.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/
public static native gcc_jit_timer gcc_jit_timer_new();

/* Release a gcc_jit_timer instance.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/
public static native void gcc_jit_timer_release(gcc_jit_timer timer);

/* Associate a gcc_jit_timer instance with a context.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/
public static native void gcc_jit_context_set_timer(gcc_jit_context ctxt,
			   gcc_jit_timer timer);

/* Get the timer associated with a context (if any).

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/

public static native gcc_jit_timer gcc_jit_context_get_timer(gcc_jit_context ctxt);

/* Push the given item onto the timing stack.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/

public static native void gcc_jit_timer_push(gcc_jit_timer timer,
		    @Cast("const char*") BytePointer item_name);
public static native void gcc_jit_timer_push(gcc_jit_timer timer,
		    String item_name);

/* Pop the top item from the timing stack.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/

public static native void gcc_jit_timer_pop(gcc_jit_timer timer,
		   @Cast("const char*") BytePointer item_name);
public static native void gcc_jit_timer_pop(gcc_jit_timer timer,
		   String item_name);

/* Print timing information to the given stream about activity since
   the timer was started.

   This API entrypoint was added in LIBGCCJIT_ABI_4; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_TIMING_API
*/

public static native void gcc_jit_timer_print(gcc_jit_timer timer,
		     @Cast("FILE*") Pointer f_out);


// #define LIBGCCJIT_HAVE_gcc_jit_rvalue_set_bool_require_tail_call

/* Mark/clear a call as needing tail-call optimization.

   This API entrypoint was added in LIBGCCJIT_ABI_6; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_rvalue_set_bool_require_tail_call
*/
public static native void gcc_jit_rvalue_set_bool_require_tail_call(gcc_jit_rvalue call,
					   int require_tail_call);

// #define LIBGCCJIT_HAVE_gcc_jit_type_get_aligned

/* Given type "T", get type:

     T __attribute__ ((aligned (ALIGNMENT_IN_BYTES)))

   The alignment must be a power of two.

   This API entrypoint was added in LIBGCCJIT_ABI_7; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_aligned
*/
public static native gcc_jit_type gcc_jit_type_get_aligned(gcc_jit_type type,
			  @Cast("size_t") long alignment_in_bytes);

// #define LIBGCCJIT_HAVE_gcc_jit_type_get_vector

/* Given type "T", get type:

     T  __attribute__ ((vector_size (sizeof(T) * num_units))

   T must be integral/floating point; num_units must be a power of two.

   This API entrypoint was added in LIBGCCJIT_ABI_8; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_vector
*/
public static native gcc_jit_type gcc_jit_type_get_vector(gcc_jit_type type, @Cast("size_t") long num_units);


// #define LIBGCCJIT_HAVE_gcc_jit_function_get_address

/* Get the address of a function as an rvalue, of function pointer
   type.

   This API entrypoint was added in LIBGCCJIT_ABI_9; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_function_get_address
*/
public static native gcc_jit_rvalue gcc_jit_function_get_address(gcc_jit_function fn,
			      gcc_jit_location loc);


// #define LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector

/* Build a vector rvalue from an array of elements.

   "vec_type" should be a vector type, created using gcc_jit_type_get_vector.

   This API entrypoint was added in LIBGCCJIT_ABI_10; you can test for its
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_rvalue_from_vector
*/
public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_vector(gcc_jit_context ctxt,
					gcc_jit_location loc,
					gcc_jit_type vec_type,
					@Cast("size_t") long num_elements,
					@Cast("gcc_jit_rvalue**") PointerPointer elements);
public static native gcc_jit_rvalue gcc_jit_context_new_rvalue_from_vector(gcc_jit_context ctxt,
					gcc_jit_location loc,
					gcc_jit_type vec_type,
					@Cast("size_t") long num_elements,
					@ByPtrPtr gcc_jit_rvalue elements);

// #define LIBGCCJIT_HAVE_gcc_jit_version

/* Functions to retrive libgccjit version.
   Analogous to __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__ in C code.

   These API entrypoints were added in LIBGCCJIT_ABI_13; you can test for their
   presence using
     #ifdef LIBGCCJIT_HAVE_gcc_jit_version
 */
public static native int gcc_jit_version_major();
public static native int gcc_jit_version_minor();
public static native int gcc_jit_version_patchlevel();

// #ifdef __cplusplus
// #endif /* __cplusplus */

// #endif  /* LIBGCCJIT_H  */


}
